var fetch = require("node-fetch"),
    striptags = require("striptags"),
    fn = require("./functions"),
    Minecraft = require("minecraft-lib")

//#region Data Functions
async function getServerData()
{
    let serverData = await Minecraft.servers.get("play.noblerealms.com").catch(err => { return err }),
        emcData = {}

    if (!serverData || !serverData.players)
    {
        emcData["serverOnline"] = false
        emcData["online"] = 0
        emcData["max"] = 0
    }
    else
    {
        emcData["serverOnline"] = true
        emcData["online"] = serverData.players.online
        emcData["max"] = serverData.players.max
    }

    return emcData
}

async function getServerInfo()
{
    let serverData = await getServerData(),
        playerData = await getPlayerData()

    info = serverData

    if (playerData != null)
    {
        info["towny"] = playerData.currentcount
        info["storming"] = playerData.hasStorm
        info["thundering"] = playerData.isThundering
    }
        
    if (info["online"] == 0 || !info["online"]) info["queue"] = 0
    else info["queue"] = info["online"] - info["towny"]

    return info
}

async function getPlayerData()
{
    let playerData = await fetch("https://map.noblerealms.com/up/world/world/").then(response => response.json()).catch(err => {})  

    if (!playerData || !playerData.players) return
    else return playerData
}

async function getOnlinePlayerData()
{
    let playerData = await getPlayerData() 

    if (!playerData || !playerData.players) return
    else return fn.editPlayerProps(playerData.players)
}

async function getMapData()
{
    let mapData = await fetch("https://map.noblerealms.com/tiles/_markers_/marker_world.json").then(response => response.json()).catch(err => {})   

    if (!mapData) return
    else return mapData
}
//#endregion

//#region Usable Functions
async function getTown(townNameInput)
{
    let towns = await getTowns()
    if (!towns) return

    let foundTown = towns.find(town => town.name.toLowerCase() == townNameInput.toLowerCase())

    if (!foundTown) return "That town does not exist!"
    else { 
		return foundTown;
		}
}

async function getTowns()
{
    let mapData = await getMapData(),
        ops = await getOnlinePlayerData(),
        townsArray = [], townsArrayNoDuplicates = []
    
    if (!mapData || !ops) return null

    if (mapData.sets["towny.markerset"] != null || mapData.sets["towny.markerset"] != undefined)
    {
        var townData = mapData.sets["towny.markerset"].areas
        var markerData = mapData.sets["towny.markerset"].markers
    }

    let townAreaNames = Object.keys(townData)
    let townMarkerNames = Object.keys(markerData)

    for (let i = 0; i < townAreaNames.length; i++)
    {      
        let town = townData[townAreaNames[i]]
        let marker = markerData[townMarkerNames[i]]
        let rawinfo = town.desc.split("<br />")
        var info = []

        rawinfo.forEach(x => 
        {
            info.push(striptags(x)) // Strips html tags from town desc
        })

        var townName = info[0].split(" (")[0].trim()
        if (townName.endsWith("(Shop)")) continue
        var markerName = townName + '__home'
      
        var mayor = info[1].slice(7)
        if (mayor == "") continue
        
        var nationName = info[0].split(" (")[1].slice(0, -1) == "" ? "No Nation" : info[0].split(" (")[1].slice(0, -1).trim(),
            residents = info[2].slice(12).split(",  ")
        
        var nation = info[9].slice(8) == "" ? "No Nation" : info[9].slice(8)
        //if(nation == '') nation == 'No Nation'

        let currentTown = 
        {
            area: fn.calcPolygonArea(town.x, town.z, town.x.length) / 16 / 16,
            x: Math.round((Math.max(...town.x) + Math.min(...town.x)) / 2),
            z: Math.round((Math.max(...town.z) + Math.min(...town.z)) / 2),
            name: fn.removeStyleCharacters(townName),
            cat: fn.removeStyleCharacters(nationName),
            mayor: info[1].slice(7),
            residents: residents,
            onlineResidents: ops.filter(op => residents.find(resident => resident == op.name)),
            pvp: info[5].slice(5) == "true" ? true : false,
            mobs:info[6].slice(6) == "true" ? true : false,
            public: info[7].slice(8) == "true" ? true : false,
            explosion: info[8].slice(11) == "true" ? true : false,
            nation: nation
        }
        
        townsArray.push(currentTown)
      }
	
    // TOWN LOGIC \\  
    townsArray.forEach(function (a) 
    {                   
          // If town doesnt exist, add it.
          if (!this[a.name]) 
          {      
              let nationResidents = []
            
              if (a.capital || a.nation != "No Nation")
              {
                  for (let i = 0; i < townsArray.length; i++)
                  {
                      var currentNation = townsArray[i].nation
                      let residents = townsArray[i].residents
                      
                      if (currentNation == a.nation)
                      {
                          for (let i = 0; i < residents.length; i++)
                          {
                              let currentResident = residents[i]
                              
                              nationResidents.push(currentResident)
                          }
                      }
                  }
              }
            
              this[a.name] = 
              { 
                  name: a.name, 
                  cat: a.cat,
                  residents: a.residents,
                  nationResidents: fn.removeDuplicates(nationResidents),
                  area: a.area,
                  mayor: a.mayor,
                  pvp: a.pvp,
                  mobs: a.mobs,
                  public: a.public,
                  explosion: a.explosion,
                  nation: a.nation,
                  x: a.x,
                  z: a.z
              }    

              townsArrayNoDuplicates.push(this[a.name])
          }
          else
          {                         
              this[a.name].area += a.area
          }
    }, Object.create(null))
    return townsArrayNoDuplicates
}

async function getNation(nationNameInput)
{
    let nations = await getNations()
    if (!nations) return

    let foundNation = nations.find(nation => nation.name.toLowerCase() == nationNameInput.toLowerCase())
    if (!foundNation) return "That town does not exist!"
    else { 
		return foundNation;
		}
}

async function getNations()
{
    let towns = await getTowns()
    if (!towns) return
    
    let mapData = await getMapData()

    let nationsArray = []

    towns.forEach(function (town) 
    {
        if (town.cat != "No Nation")
        {
            // If nation doesn't exist
            if (!this[town.cat]) 
            {          
                this[town.cat] = 
                { 
                    name: town.cat,
                    residents: town.residents,
                    towns: [],
                    king: "WIP",
                    capitalName: "WIP",
                    capitalX: 0,
                    capitalZ: 0,
                    area: 0
                }

                nationsArray.push(this[town.cat])
            }

            // If it already exists, add up stuff.
            this[town.cat].residents = fn.removeDuplicates(this[town.cat].residents.concat(town.residents))       
            this[town.cat].area += town.area // Add up the area

            // If the nation name is equal to the current towns nation
            if (this[town.cat].name == town.cat)
            {
                this[town.cat].towns.push(' ' + town.name) // Push it to nation towns
                
        let townsArray = [], townsArrayNoDuplicates = []
    
    if (!mapData) return null

    if (mapData.sets["towny.markerset"] != null || mapData.sets["towny.markerset"] != undefined)
    {
        var townData = mapData.sets["towny.markerset"].areas
		var townMarkers = mapData.sets["towny.markerset"].markers
    }

    let townAreaNames = Object.keys(townData)
	let townMarkerNames = Object.keys(townMarkers)

    for (let i = 0; i < townMarkerNames.length; i++)
    {      
		let marker = townMarkers[townMarkerNames[i]]
        let markerName = town.name + '__home'
        if(townMarkerNames[i] === markerName)
        {
        let icon = marker.icon
                
                if(icon === 'king')
               {
                this[town.cat].capitalX = town.x
                this[town.cat].capitalZ = town.z
                this[town.cat].capitalName = town.name
                this[town.cat].king = town.mayor
               }
            }
    	  }
        }
      }
    }, Object.create(null))

    return nationsArray
}

async function getOnlinePlayer(playerNameInput)
{
  if (!playerNameInput) throw { name: "NO_PLAYER_INPUT", message: "No player was inputted!" }
  else if (!isNaN(playerNameInput)) throw { name: "INVALID_PLAYER_TYPE", message: "Player cannot be an integer." }

  var ops = await getOnlinePlayers(true)

  let foundPlayer = ops.find(op => op.name.toLowerCase() == playerNameInput.toLowerCase())
  if (!foundPlayer) throw { name: "INVALID_PLAYER", message: "That player is offline or does not exist!" }

  return foundPlayer
}

async function getOnlinePlayers(includeResidentInfo)
{
    var onlinePlayers = await getOnlinePlayerData()
    
    if (!includeResidentInfo) return onlinePlayers

    let residents = await getResidents(),
        merged = []
    
    for (let i = 0; i < onlinePlayers.length; i++) 
    {
        merged.push
        ({
            ...onlinePlayers[i], 
            ...(residents.find((itmInner) => itmInner.name === onlinePlayers[i].name))
        })
    }

    return merged
}

async function getResident(residentNameInput)
{
    let residents = await getResidents(),
        foundResident = residents.find(resident => resident.name.toLowerCase() == residentNameInput.toLowerCase())

    if (!foundResident) {
		foundResident = residents.find(resident => resident.name.toLowerCase() == " " + residentNameInput.toLowerCase())
	let townless = 
            {
                name: residentNameInput,
                town: "None",
                nation: "None",
                rank: "Townless"
            }
			if (!foundResident) return townless;
			else return foundResident
	}
    else return foundResident
}

async function getResidents()
{
    let towns = await getTowns(),
        residentsArray = []

    for (let i = 0; i < towns.length; i++)
    {
		const currentRes = towns[i].residents;
		var splitRes = currentRes.toString().split(', ');
        var currentTown = towns[i],
            rank

        for (let i = 0; i < splitRes.length; i++)
        {
            var currentResident = splitRes[i]
            if (currentTown.capital && currentTown.mayor == currentResident) rank = "Nation Leader"
            else if (currentTown.mayor == currentResident) rank = "Mayor"
            else rank = "Resident"

            let resident = 
            {
                name: currentResident,
                town: currentTown.name,
                nation: currentTown.cat,
                rank: rank
            }

            residentsArray.push(resident)
        }
    }

    return residentsArray
}

async function getAllPlayers()
{
    var onlinePlayers = await getOnlinePlayerData()
        residents = await getResidents()

    let merged = []
    
    for (let i = 0; i < residents.length; i++) 
    {
        merged.push
        ({
            ...residents[i], 
            ...(onlinePlayers.find((itmInner) => itmInner.name === residents[i].name))
        })
    }

    return merged
}

async function getPlayer(playerNameInput)
{
    var allPlayers = await getAllPlayers()
    return allPlayers.find(p => p.name.toLowerCase() == playerNameInput.toLowerCase())
}

async function getTownless()
{
    let mapData = await getMapData(),
        onlinePlayers = await getOnlinePlayers()

    if (!onlinePlayers || !mapData) return

    var townData = mapData.sets["towny.markerset"].areas
    
    let townAreaNames = Object.keys(townData)

    var allTowns = [], allResidents = []
    
    for (let i = 0; i < townAreaNames.length; i++)
    {
        let town = townData[townAreaNames[i]]
        let rawinfo = town.desc.split("<br />")
        var info = []

        rawinfo.forEach(x => 
        {
            info.push(striptags(x)) // Strips html tags from town desc
        })

        var name = info[0].split(" (")[0].replace(/_/gi, " ").trim()
        if (name.endsWith("(Shop)")) continue
                
        var mayor = info[1].slice(7)
        if (mayor == "") continue
        
        let residents = info[2].slice(9).split(", ")

        allTowns.push(residents)
    }

    // Push every resident in every town
    allTowns.forEach(town => 
    {
        town.forEach(resident => allResidents.push(resident))
    })

    var townlessPlayers = onlinePlayers.filter(op => !allResidents.find(resident => resident == op.name))
                                                
    townlessPlayers.sort((a, b) => 
    {
        if (b.name.toLowerCase() < a.name.toLowerCase()) return 1
        if (b.name.toLowerCase() > a.name.toLowerCase()) return -1
    })

    return townlessPlayers
}

async function getInvitableTowns(nationName, includeBelonging)
{
    let nation = await getNation(nationName)
    if (nation == "That nation does not exist!") return nation

    let towns = await getTowns()
    if (!towns) return

    function invitable(town)
    {
        if (includeBelonging) return Math.hypot(town.x - nation.capitalX, town.z - nation.capitalZ) <= 3000 && town.nation != nationName
        else return Math.hypot(town.x - nation.capitalX, town.z - nation.capitalZ) <= 15000 && town.nation != nationName && town.nation == "No Nation"
    }

    return towns.filter(town => invitable(town))
}

async function getJoinableNations(townName)
{
    let town = await getTown(townName)
    if (town == "That town does not exist!") return town
    
    let nations = await getNations()
    if (!nations) return

    function joinable(nation)
    {
        return Math.hypot(nation.capitalX - town.x, nation.capitalZ - town.z) <= 15000 && town.nation == "No Nation"
    }

    return nations.filter(n => joinable(n))
}

async function getNearbyPlayers(xInput, zInput, xRadius, zRadius)
{
    let allPlayers = await getAllPlayers()

    return allPlayers.filter(p => 
    {            
        if (p.x != 0 && p.z != 0)
        {
            return (p.x <= (xInput + xRadius) && p.x >= (xInput - xRadius)) &&
                   (p.z <= (zInput + zRadius) && p.z >= (zInput - zRadius))
        }
    })
}

async function getNearbyTowns(xInput, zInput, xRadius, zRadius)
{
    let towns = await getTowns()

    return towns.filter(t => 
    {            
        return (t.x <= (xInput + xRadius) && t.x >= (xInput - xRadius)) &&
               (t.z <= (zInput + zRadius) && t.z >= (zInput - zRadius))
    })
}

async function getSieges()
{
    let mapData = await getMapData(),
        onlinePlayers = await getOnlinePlayers()

    if (!onlinePlayers || !mapData) return

    var townData = mapData.sets["siegewar.markerset"].markers
    
    let townAreaNames = Object.keys(townData)

    var allTowns = [], allResidents = []
    
	
    for (let i = 0; i < townAreaNames.length; i++)
    {
        let town = townData[townAreaNames[i]]
        let rawinfo = town.desc.split("<br />" || "</b>")
        var info = []
        let sides = town.label.split(" ")

        rawinfo.forEach(x => 
        {
            info.push(striptags(x)) // Strips html tags from town desc
        })
		
			let currentTown = 
        {
            Siege: town.label.slice(7),
            Attacker: sides[1],
            Defender: sides[3],
            Type: info[1].slice(6),
            SiegeBalance: info[2].slice(15),
            TimeLeft: info[3].slice(11),
			WarChest: info[4].slice(11),
			BannerControl: info[5].slice(16),
			BattlePoints: info[6].slice(15),
			BattleTimeLeft: info[7].slice(18),
			x: town.x,
			z: town.z
        }
		var cur = Object.values(currentTown);
        allTowns.push(cur)
    }
	return allTowns
}

async function getTown(townNameInput)
{
    let towns = await getTowns()
    if (!towns) return

    let foundTown = towns.find(town => town.name.toLowerCase() == townNameInput.toLowerCase())

    if (!foundTown) return "That town does not exist!"
    else { 
		return foundTown;
		}
}

async function getCamps()
{
    let mapData = await getMapData(),
        ops = await getOnlinePlayerData(),
        townsArray = [], townsArrayNoDuplicates = []
    
    if (!mapData || !ops) return null

    if (mapData.sets["townycamps.markerset"] != null || mapData.sets["townycamps.markerset"] != undefined)
    {
		var townMarkers = mapData.sets["townycamps.markerset"].markers
    }
	let townMarkerNames = Object.keys(townMarkers)

    for (let i = 0; i < townMarkerNames.length; i++)
    {      
		let marker = townMarkers[townMarkerNames[i]]

        var townName = marker.label
        //var mayor = marker.label.slice(0, -11)

        let currentTown = 
        {
            x: marker.x,
            z: marker.z,
            name: fn.removeStyleCharacters(townName),
            mayor: marker.label.slice(0, -11),
            //onlineResidents: ops.filter(op => mayor.find(resident => resident == op.name)),
        }
        
        townsArray.push(currentTown)
    }
	
    // TOWN LOGIC \\  
    townsArray.forEach(function (a) 
    {                   
          // If town doesnt exist, add it.
          if (!this[a.name]) 
          {
            
              this[a.name] = 
              { 
                  name: a.name,
                  mayor: a.mayor,
                  x: a.x,
                  z: a.z
              }    

              townsArrayNoDuplicates.push(this[a.name])
          }
          else
          {                         
              this[a.name].area += a.area
          }
    }, Object.create(null))

    return townsArrayNoDuplicates
}

async function getRuins()
{
    let mapData = await getMapData(),
        ops = await getOnlinePlayerData(),
        townsArray = [], townsArrayNoDuplicates = []
    
    if (!mapData || !ops) return null

    if (mapData.sets["townyruins.markerset"] != null || mapData.sets["townyruins.markerset"] != undefined)
    {
		var townMarkers = mapData.sets["townyruins.markerset"].markers
    }
	let townMarkerNames = Object.keys(townMarkers)

    for (let i = 0; i < townMarkerNames.length; i++)
    {      
		let marker = townMarkers[townMarkerNames[i]]

        var townName = marker.label
        //var mayor = marker.label.slice(0, -11)

        let currentTown = 
        {
            x: marker.x,
            z: marker.z,
            name: fn.removeStyleCharacters(townName),
            //onlineResidents: ops.filter(op => mayor.find(resident => resident == op.name)),
        }
        
        townsArray.push(currentTown)
    }
	
    // TOWN LOGIC \\  
    townsArray.forEach(function (a) 
    {                   
          // If town doesnt exist, add it.
          if (!this[a.name]) 
          {
            
              this[a.name] = 
              { 
                  name: a.name,
                  x: a.x,
                  z: a.z
              }    

              townsArrayNoDuplicates.push(this[a.name])
          }
          else
          {                         
              this[a.name].area += a.area
          }
    }, Object.create(null))

    return townsArrayNoDuplicates
}

async function getIcon(townNameInput)
{
    let mapData = await getMapData(),
        ops = await getOnlinePlayerData(),
        townsArray = [], townsArrayNoDuplicates = []
    
    if (!mapData || !ops) return null

    if (mapData.sets["towny.markerset"] != null || mapData.sets["towny.markerset"] != undefined)
    {
        var townData = mapData.sets["towny.markerset"].areas
		var townMarkers = mapData.sets["towny.markerset"].markers
    }

    let townAreaNames = Object.keys(townData)
	let townMarkerNames = Object.keys(townMarkers)

    for (let i = 0; i < townAreaNames.length; i++)
    {      
        let town = townData[townAreaNames[i]]
		let marker = townMarkers[townMarkerNames[i]]
        let icon = marker.icon
        let rawinfo = marker.desc.split("<br />")
        var info = []

        rawinfo.forEach(x => 
        {
            info.push(striptags(x)) // Strips html tags from town desc
        })

        var townName = info[0].split(" (")[0].trim()
        
        if(townName === townNameInput)
            {
                return icon
            }
    }
}
        
    

async function getNearbyNations(xInput, zInput, xRadius, zRadius)
{
    let nations = await getNations()

    return nations.filter(n => 
    {            
        return (n.capitalX <= (xInput + xRadius) && n.capitalX >= (xInput - xRadius)) &&
               (n.capitalZ <= (zInput + zRadius) && n.capitalZ >= (zInput - zRadius))
    })
}
//#endregion

//#region Exports
module.exports =    
{
    getTown,
    getTowns,
    getNation,
    getNations,
    getResident,
    getResidents,
    getOnlinePlayer,
    getOnlinePlayers,
    getAllPlayers,
    getPlayer,
    getTownless,
    getServerInfo,
    getInvitableTowns,
    getJoinableNations,
    getNearbyPlayers,
    getNearbyTowns,
	getSieges,
    getCamps,
    getRuins,
    getIcon,
    getNearbyNations
}
//#endregion